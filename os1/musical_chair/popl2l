\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}

\title{This document is generated by \LaTeX \\\\ \\ POPL-2}\\

\author{CS18BTECH11018}
\date{}

\usepackage{natbib}


\begin{document}

\maketitle

\section{}
\textbf{3 . Describe how to maintain the static chain during a subroutine call.}\\
The general method is for the caller to compute the callee's static link and to pass it as an extra but as a hidden parameter.\\

\section{}
\textbf{5 . What are the purposes of the stack pointer and frame pointer registers? Why
does a subroutine often need both?
}\\
Stack pointer points to first/last(depends on machine and compiler) unused location on the stack  and Frame pointer points to a location near the bottom of the frame. We need a stack pointer to add something new to the stack and we need frame pointer for debugging. So both are required for a subroutine.\\

\section{}
\textbf{6 . Why do RISC machines typically pass subroutine parameters in registers rather
than on the stack?
}\\
A subroutine with no local variables and nothing to save doesnot need a stack frame on RISC machine and few simple subroutines might nit touvh the memory at all. So they can take the arguments in registers and entire computation can be done only in registers(caller-saves).\\

\section{}
\textbf{8 . If work can be done in either the caller or the callee, why do we typically prefer
to do it in the callee?
}\\

\section{}
\textbf{9 . Why do compilers typically allocate space for arguments in the stack, even
when they pass them in registers?
}\\
When we allocate the space for arguments in the stack, even when they pass them in registers, we don't need any special method to access parameters of register, we can handle all parameters similarly, so that it makes it easy for us. \\
\\

\section{}
\textbf{11 . How does an in-line subroutine differ from a macro}\\
Both macro and in-line subroutine expand they are invocated but the way compiler handles them is different.While the  inline functions are expanded during compilation , macros are expanded when the program is processed by the preprocessor. \\  

\section{}
\textbf{19 . Give an example in which it is useful to return a reference from a function in
C++.
}\\
 When a variable is returned by reference, a reference to the variable is passed back to the caller. The caller can then use this reference to continue modifying the variable, which can be useful at times. Return by reference is also fast, which can be useful when returning structs and classes.\\ 
 
 So consider a case where we immediately want to modify the output of a subroutine without creating a new copy and just modifying the original returned variable, then return by reference is useful. \\
 \\
\section{}
\textbf{22 . What are default parameters? How are they implemented?}\\
\\
A default parameter is one which need not be explicitly provided by the caller and in case if it is not provided, some default value will be used.\\
The implementation is fairly simple. If any argument is missed,then the compiler generates a calling sequence that
loads those defaults into registers or pushes them onto the stack, as appropriate. \\
\\
\section{}
\textbf{24 . Explain the value of variable-length argument lists. What distinguishes such
lists in Java and C# from their counterparts in C and C++?
}\\
Variable length argument lists allow function to act based on  the number of arguments given. \\
Java and C# support variable numbers of
parameters but they do so in a type-safe manner,
by requiring all trailing parameters to share a common type unlike C and C++.\\

\section{}
\textbf{27 . How does a generic subroutine differ from a macro?}\\
Subroutines can be used when you need to pass arguments, get a return value, or activate the independent execution of logic but macros can be used when defining run-time interface parameters. \\

\section{}
\textbf{30 . What does it mean for a generic parameter to be constrained? Explain the
difference between explicit and implicit constraints.}\\
\\

\section{}
\textbf{35 . Explain how to implement exceptions in a way that incurs no cost in the common case (when exceptions don’t arise).
}\\
we have to produce a table containing starting address of a block of code and the address of corresponding exception handler during compile time and sort the table in the order of 1st field. In case of exception, we search for its handler in the table using binary search, with program counter as a key. So this way, we avoid additional costs in case of no exceptions as this whole search process occurs only when exception arises.\\

\section{}
\textbf{39 . Summarize the shortcomings of the setjmp and longjmp library routines
of C}\\
\\
Setjmp uses buffer to remeber current position and returns 0 and longjmp is used to go back to the place buffer is pointing to. Longjmp routines have undefined behaviour once the program exits the protected code and setjmp has limited extent for storing information.Cache coherence problems may also arise because of longjmp.\\
\section{}
\textbf{40 . What is a volatile variable in C? Under what circumstances is it useful?
}\\
A Volatile variable is type of of variable which can change it's value in memory spontaneously and it is useful in conditions where there is a possibility of loosing the changes that were cached in registers will be lost.

\section{}
\textbf{42 . What is the difference between a coroutine and a thread?
}\\
The major difference between coroutines and a threads is that co-routines are cooperatives whereas threads are preemptive. With coroutines user should decide when to switch 
coroutines.\\
\section{}
\textbf{46 . What is discrete event simulation? What is its connection with coroutines?}\\
A discrete event simulation is one in which the model is naturally expressed in terms of events that happen at specific times. This is the most important application of coroutines.\\

\section{}
\textbf{47 . What is an event in the programming language sense of the word?}\\
An event is an action or occurrence  to to which programming which is currently running needs to responds. It may be something like user input from some console, they can happen arbitrarily.\\

\section{}
\textbf{8.3 Using your favorite language and compiler, write a program that can tell the order in which certain subroutine parameters are evaluated.}\\
It could be possible that with that architecture of the machine and compiler, that variable might have been initialized to 0 and value isn't being lost when function is recalled. But this might not be same on all machines , so behavior on other
systems might be different, or nondeterministic.\\

\section{}
\textbf{8.14 Consider the following declaration in C:
double(*foo(double (*)(double, double[]), double)) (double, ...);
Describe in English the type of foo .
}\\

\section{}
\textbf{8.29}\\
Whenever compiler gets to know that object is about to go out of scope, then the corresponding destructor must be invoked by compiler. The destructor then should de-allocate all the resources used by that object.\\

\section{}
\textbf{1 . What are generally considered to be the three defining characteristics of
object-oriented programming? 
}\\
Encapsulation, Inheritance , Polymorphism are generally considered to be the three defining characteristics of
object-oriented programming.\\

\section{}
\textbf{3 . Name three important benefits of abstraction.}\\
\\
Abstraction is selecting data from a larger pool to show only the relevant details to the object. It helps to reduce programming complexity and effort.\\
It minimizes programmers effort, it makes updating a program easier.
\section{}
\textbf{6. What is the purpose of the “private” part of an object interface? Why is it Required?
}\\
If an entity of a class is defined as private then it can be can accessed by the entities from that class only. It is used to increase the security of program and avoid unnecessary exposure of the data. \\

\section{}
\textbf{7. What is the purpose of the :: operator in C++?}\\
It is the scope resolution operator.It can be used when we are defining a member function of the class outside the class, then we can use the scope resolution operator.\\

\section{}
\textbf{10. What are constructors and destructors?}\\
Constructors and destructors are special member functions of the class. The Compiler calls the Constructor whenever an object is created and the destructor whenever object is about to die.\\

\section{}
\textbf{14. Explain the significance of the this parameter in object-oriented languages.}\\
This pointer is used to represent the address of an object inside a member function.this pointer is used to represent the address of an object inside a member function.One important  application of this pointer is distinguishing data members from local variables of member functions if they have same name.\\

\section{}
\textbf{16. Explain the distinctions among private, protected, and public class members in C++}\\
1.Public : Any class member defined as public is accessible to everyone.\\
2.Private : Any class member defined as private is accessible only by the functions inside the class.\\
3.Protected :  Any class member defined as public is accessible to sub-classes also.\\

\section{}
\textbf{20. How do inner classes in Java differ from most other nested classes?
}\\
Class which is declared inside another class is called nested class.Nested classes are divided into two categories: static and non-static. Nested classes that are declared static are simply called static nested classes. Non-static nested classes are called inner classes.\\

\section{}
\textbf{22. What are extension methods in C#? What purpose do they serve?}\\
 An extension method is  a static method and must be located in a static class. It enables us to add methods to existing types without creating a new derived type, recompiling, or modify the original types.\\

\section{}
\textbf{23. Does a constructor allocate space for an object? Explain.}\\
No constructor doesn't allocate the space for an object. Some other mechanism takes care of it, constructor just takes care of initialisation in allocated memory.\\

\section{}
\textbf{25. Why is object initialization simpler in a language with a reference model of variables (as opposed to a value model)?
}\\
If we have variables as references, we should create objects explicitly whereas, if variables are values, then object creation can occur implicitly. If objects are created explicitly by us we can have control over over the appropriate constructor to be called but we lose this flexibility in case of value model, so object initialization simpler in a language with a reference model of variables.\\ 

\section{}
\textbf{28. Summarize the rules in C++ that determine the order in which constructors are called for a class, its base class(es), and the classes of its fields. How are
these rules simplified in other languages?
}\\
\\
Whenever we create an object of a class, the default constructor of that class is invoked automatically. But whenever we create an object of a class which is inherited from other class, the default constructor of the derived class will be invoked but before that the default constructor of all of the base classes will be invoke, i.e the order of invokation is that the base class’s default constructor will be invoked first and then the derived class’s default constructor will be invoked. \\

\section{}
\textbf{29. Explain the difference between initialization and assignment in C++.}\\
Initialization is creating a variable and getting it ready for further use. Assignment is one way of initialization but not the only way.\\

\section{}
\textbf{31. Explain the difference between dynamic and static method binding (i.e.,
between virtual and nonvirtual methods).
}\\
The binding which can be resolved at compile time is static binding but in dynamic binding compiler doesn’t decide the method to be called. Binding of all the static, private and final methods is done at compile-time whereas  overriding is an example of dynamic binding.\\

\section{}
\textbf{35. Explain the connection between dynamic method binding and polymorPhism.}\\
With dynamic binding, we can have methods with same name having
different implementation in different classes by deciding the actual method to be invoked at run time based on the object, thus allowing run-time polymorphism.\\

\section{}
\textbf{40. What is an abstract (deferred) class?}\\
Abstract class has abstract methods. Abstract methods are nothing as pure virtual methods. Abstract classes can't have instances.\\

\section{}
\textbf{43. Explain the importance of virtual methods for object closures.}\\
Creation of object closures rely on dynamic method binding. We allow arbitrary subroutines with arbitrary number of arguments to be scheduled  using dynamic method
binding.\\

\section{}
\textbf{9.14  Compare Java final methods with C++ non virtual methods. How are they the same? How are they different?
}\\
Non-virtual member functions of C++ can have the same signature in inheriting classes in C++ but Java avoids eclaring methods with the same signature in which the base class declares that method final. Virtuality in C++ takes care of calling appropriate method.\\

\section{}
\textbf{9.17}\\
b just can acts as an integer overwriting previous its type of char.\\

\section{}
\textbf{9.21}\\
Yes we can have objects of classes derived from foo assigned to foo*, but we can't have the type foo because , abstract classes can't have instances.(objects)


\end{document}